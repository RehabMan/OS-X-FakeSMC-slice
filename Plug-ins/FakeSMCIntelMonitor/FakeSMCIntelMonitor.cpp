/* *  FakeSMCIntelMonitor.cpp *  FakeSMCIntelMonitor * *  Created by mozo on 18/05/10. *  Copyright © 2010 mozodojo. All rights reserved. * *	This code includes parts of original Open Hardware Monitor code *	Copyright © 2010 Michael Möller. All Rights Reserved. *///#include "FakeSMCIntelMonitor.h"#include "Sensor.h"#define super IOServiceOSDefineMetaClassAndStructors(FakeSMCIntelMonitor, IOService)bool FakeSMCIntelMonitor::init(OSDictionary *properties){    bool res = super::init(properties);	OSNumber *  numObj;	CpuTjmax = 0;	numObj  = OSDynamicCast( OSNumber, getProperty("TJMax") );	if ( numObj )    {		CpuTjmax = numObj->unsigned32BitValue();		}	return res;}IOService* FakeSMCIntelMonitor::probe(IOService *provider, SInt32 *score){	if (super::probe(provider, score) != this) return 0;		cpuid_update_generic_info();	/*	if (strcmp(cpuid_info()->cpuid_vendor, CPUID_VID_INTEL) != 0)	{		WarningLog("No Intel processor found, kext will not load");		return false;	}*/		if(!(cpuid_info()->cpuid_features & CPUID_FEATURE_MSR))	{		WarningLog("Processor does not support Model Specific Registers, kext will not load");		return false;	}		CpuCount = cpuid_info()->core_count;//cpuid_count_cores();		if(CpuCount == 0)	{		WarningLog("CPUs not found, kext will not load");		return false;	} 	UInt32 CpuFamily = cpuid_info()->cpuid_family;	UInt32 CpuModel = cpuid_info()->cpuid_model;	UInt32 CpuStepping =  cpuid_info()->cpuid_stepping;		InfoLog("CPU family 0x%x, model 0x%x, stepping 0x%x", (unsigned int)CpuFamily, (unsigned int)CpuModel, (unsigned int)CpuStepping);	InfoLog("Found %d cores %d threads", CpuCount, cpuid_info()->thread_count);		BusClock = (gPEClockFrequencyInfo.bus_frequency_max_hz >> 2) + Mega;	if (BusClock >= (420 * Mega)) {		BusClock >>=2;	}/*	IORegistryEntry * entry = fromPath("/efi/platform", gIODTPlane);		if (entry)	{		OSObject * object = entry->getProperty("FSBFrequency");				if (object && (OSTypeIDInst(object) == OSTypeID(OSData))) 		{			OSData * data = OSDynamicCast(OSData, object);						if (data) 			{				BusClock = * (UInt32 *) data->getBytesNoCopy();				gPEClockFrequencyInfo.bus_frequency_max_hz = BusClock << 2;			}		}	}	*/		BusClock = BusClock / Mega;	FSBClock = gPEClockFrequencyInfo.bus_frequency_max_hz / Mega;	InfoLog("BusClock=%dMHz FSB=%dMHz", (int)BusClock, (int)FSBClock);		/*	 // ***** Disable C2+ states for C Stop CPU's	 if (CPUState.ConstantTSC && !CPUState.Intel.NoCStopTSC)	 {	 WarningLog("Your CPU supports constant TSC but only in C0 and C1, you should disable C2+ states");	 wrmsr64(MSR_IA32_MISC_ENABLE, (rdmsr64(MSR_IA32_MISC_ENABLE) & ~(0x3ULL << 26)));	 }	 	*/	CpuSignature = cpuid_info()->cpuid_signature;	CpuCoreTech = Unknown;	CpuNonIntegerBusRatio = (rdmsr64(MSR_IA32_PERF_STS) & (1ULL << 46));		// Netburst	switch (CpuSignature & 0x000FF0) 	{		case 0x000F10:		case 0x000F20:			CpuCoreTech = IntelNetburstOld;			break;		case 0x000F30:		case 0x000F40:		case 0x000F60:			CpuCoreTech = IntelNetburstNew;			break;	}		// Core/P-M	switch (CpuSignature & 0x0006F0) 	{		case 0x000690:		case 0x0006D0:			CpuCoreTech = IntelPentiumM;			break;		case 0x0006E0:		case 0x0006F0:			CpuCoreTech = IntelCore;			break;	}		// Core/Core45/i7	switch (CpuSignature & 0x0106F0) 	{		case 0x010660:			CpuCoreTech = IntelCore;			break;		case 0x010670:		case 0x0106D0:			CpuCoreTech = IntelCore45;			break;		case 0x0106C0:			CpuCoreTech = IntelAtom;			break;		case 0x0106A0:			CpuCoreTech = IntelCoreI7;			break;	}		if (CpuCoreTech == Unknown) 		WarningLog("CPU Core technology unknown");		bool CpuTjmax15 = false;	CpuDynamicFSB = 0;		// Check CPU is mobile	switch (CpuCoreTech) 	{		case IntelPentiumM:			CpuMobile = true;			break;		case IntelNetburstOld:			CpuMobile = (rdmsr64(MSR_P4_EBC_FREQUENCY_ID) & (1 << 21));			break;		case IntelNetburstNew:			CpuMobile = (rdmsr64(MSR_P4_EBC_FREQUENCY_ID) & (1 << 21));			break;		case IntelCoreI7:		case IntelCore:		case IntelCore45:		case IntelAtom:		{			CpuMobile = (rdmsr64(MSR_IA32_PLATFORM_ID) & (1 << 28));						if (rdmsr64(MSR_IA32_EXT_CONFIG) & (1 << 27)) 			{				wrmsr64(MSR_IA32_EXT_CONFIG, (rdmsr64(MSR_IA32_EXT_CONFIG) | (1 << 28))); IOSleep(1);				CpuDynamicFSB = rdmsr64(MSR_IA32_EXT_CONFIG) & (1 << 28);			}						CpuTjmax15 = (rdmsr64(MSR_IA32_EXT_CONFIG) & (1 << 30));						break;		}	}		if (CpuTjmax) {		InfoLog("Manually CPU Tjmax %d", CpuTjmax);			} else {			CpuTjmax = 100;			// Find a TjMAX value		switch (CpuCoreTech) 		{		case IntelCore45:		{			if (CpuMobile) 			{				CpuTjmax += 5;								if (CpuTjmax15)					CpuTjmax -= 15;			}						break;		}		case IntelAtom:		{			if (CpuMobile) 				CpuTjmax -= 10;						break;		}		case IntelCore:		{			if ((CpuMobile) && (CpuTjmax15)) 				CpuTjmax -= 15;			switch (CpuStepping)             {                case 0x02: // G0                    CpuTjmax -= 5; break;                case 0x06: // B2                    if(CpuCount == 2 || CpuCount == 4) CpuTjmax -= 40/CpuCount; else CpuTjmax -= 15; break;                case 0x0B: // G0                    CpuTjmax -= 10; break;                case 0x0D: // M0 <- probably unneeded b/c without it it would still default.                default:                    CpuTjmax = -15; break;            } 			break;		}		case IntelCoreI7:		{			CpuTjmax = ((rdmsr64(MSR_IA32_TEMPERATURE_TARGET) >> 16) & 0xFF);			break;		}	}				InfoLog("Tjmax %u, %s CPU ", CpuTjmax, CpuMobile?"Mobile":"Desktop");	}		// Retrieving P-States  //nahuya?/*		PStateInitial.Control = rdmsr64(MSR_IA32_PERF_STS) & 0xFFFF;		PStateMaximum.Control = ((rdmsr64(MSR_IA32_PERF_STS) >> 32) & 0x1F3F) | (0x4000 * CpuNonIntegerBusRatio);	PStateMaximum.CID = ((PStateMaximum.FID & 0x1F) << 1) | CpuNonIntegerBusRatio;		PStateMinimum.FID = ((rdmsr64(MSR_IA32_PERF_STS) >> 24) & 0x1F) | (0x80 * CpuDynamicFSB);	PStateMinimum.VID = ((rdmsr64(MSR_IA32_PERF_STS) >> 48) & 0x3F);		if (PStateMinimum.FID == 0) 	{		// Probe for lowest fid		for (UInt8 i = PStateMaximum.FID; i >= 0x6; i--) 		{			wrmsr64(MSR_IA32_PERF_CTL, (rdmsr64(MSR_IA32_PERF_CTL) & 0xFFFFFFFFFFFF0000ULL) | (i << 8) | PStateMinimum.VID);			IntelWaitForSts();			PStateMinimum.FID = (rdmsr64(MSR_IA32_PERF_STS) >> 8) & 0x1F; IOSleep(1);		}				wrmsr64(MSR_IA32_PERF_CTL, (rdmsr64(MSR_IA32_PERF_CTL) & 0xFFFFFFFFFFFF0000ULL) | (PStateMaximum.FID << 8) | PStateMaximum.VID);		IntelWaitForSts();	}		if (PStateMinimum.VID == PStateMaximum.VID) 	{	// Probe for lowest vid		for (UInt8 i = PStateMaximum.VID; i > 0xA; i--) 		{			wrmsr64(MSR_IA32_PERF_CTL, (rdmsr64(MSR_IA32_PERF_CTL) & 0xFFFFFFFFFFFF0000ULL) | (PStateMinimum.FID << 8) | i);			IntelWaitForSts();			PStateMinimum.VID = rdmsr64(MSR_IA32_PERF_STS) & 0x3F; IOSleep(1);		}				wrmsr64(MSR_IA32_PERF_CTL, (rdmsr64(MSR_IA32_PERF_CTL) & 0xFFFFFFFFFFFF0000ULL) | (PStateMaximum.FID << 8) | PStateMaximum.VID);		IntelWaitForSts();	}		PStateMinimum.CID = ((PStateMinimum.FID & 0x1F) << 1) >> CpuDynamicFSB;		// Sanity check	if (PStateMaximum.CID < PStateMinimum.CID) 	{		WarningLog("Insane FID values");				CpuClock = gPEClockFrequencyInfo.cpu_frequency_max_hz / Mega;		PStatesCount = 1;	}	else	{		// Finalize P-States		// Find how many P-States machine supports		PStatesCount = PStateMaximum.CID - PStateMinimum.CID + 1;				if (PStatesCount > MaxPStateCount) 			PStatesCount = MaxPStateCount;				UInt8 vidstep;		UInt8 i = 0, invalid = 0;				vidstep = ((PStateMaximum.VID << 2) - (PStateMinimum.VID << 2)) / (PStatesCount - 1);				for (UInt8 u = 0; u < PStatesCount; u++) 		{			i = u - invalid;						PStates[i].CID = PStateMaximum.CID - u;			PStates[i].FID = (PStates[i].CID >> 1);						if (PStates[i].FID < 0x6) 				if (CpuDynamicFSB) 					PStates[i].FID = (PStates[i].FID << 1) | 0x80;				else if (CpuNonIntegerBusRatio) 					PStates[i].FID = PStates[i].FID | (0x40 * (PStates[i].CID & 0x1));						if (i && PStates[i].FID == PStates[i-1].FID)				invalid++;						PStates[i].VID = ((PStateMaximum.VID << 2) - (vidstep * u)) >> 2;		}				PStatesCount -= invalid;				CpuClock = IntelGetFrequency(PStates[0].FID);	}*/		return this;}bool FakeSMCIntelMonitor::start(IOService * provider){	if (!super::start(provider)) return false;	//InfoLog("(C) 2009 Mercurysquad, Superhai, 2010 Mojodojo, usr-sse2, Slice, All Rights Reserved");	// Printout banner	//InfoLog("%s %s (%s) %s %s [%s]", kextProductName, kextVersion, kextConfig, kextBuildDate, kextBuildTime, kextOSX);	InfoLog("(C)2008 Mercurysquad, Superhai, 2010 Mojodojo and others");		if (!(WorkLoop = getWorkLoop())) 		return false;		if (!(TimerEventSource = IOTimerEventSource::timerEventSource( this, OSMemberFunctionCast(IOTimerEventSource::Action, this, &FakeSMCIntelMonitor::loopTimerEvent)))) 		return false;		if (kIOReturnSuccess != WorkLoop->addEventSource(TimerEventSource))	{		return false;	}	Activate();	for (UInt32 i = 0; i < CpuCount; i++) 	{		char key[5];		snprintf(key, 5, "FRC%d", (int)i);		FreqBinding[i]=new FrequencySensor(this, i, key, "freq", 2);		snprintf(key, 5, "TC%dD", (int)i);		TempBinding[i]=new TemperatureSensor(this, i, key, "sp78", 2);		snprintf(key, 5, "VC%dC", (int)i);		VoltBinding[i]=new VoltageSensor(this, i, key, "fp2e", 2);	}			registerService(0);		return true;	}void FakeSMCIntelMonitor::stop (IOService* provider){	Deactivate();		for (int i=0; i<CpuCount; i++) {		if (FreqBinding[i])			delete FreqBinding[i];		if (TempBinding[i])			delete TempBinding[i];		if (VoltBinding[i])			delete VoltBinding[i];	}		super::stop(provider);}void FakeSMCIntelMonitor::free (){		super::free ();}IOReturn FakeSMCIntelMonitor::loopTimerEvent(void){	//Please, don't remove this timer! If frequency is read in OnKeyRead function, then the CPU is loaded by smcK-Stat-i and	//goes to a higher P-State in this moment, displays high frequency and switches back to low frequency.	UInt32 magic = 0;			if(LoopLock)		return kIOReturnTimeout;		LoopLock = true;		// State Readout	mp_rendezvous_no_intrs(IntelState, &magic);		for (UInt32 i = 0; i < CpuCount; i++) 	{		Frequency[i] = IntelGetFrequency(GlobalState[i].FID);		Voltage[i] = IntelGetVoltage(GlobalState[i].VID);	}	LoopLock = false;	TimerEventSource->setTimeoutMS(1000);		return kIOReturnSuccess;}void FakeSMCIntelMonitor::Activate(void){	if(Active)		return;	Active = true;		loopTimerEvent();	//	InfoLog("Monitoring started");}void FakeSMCIntelMonitor::Deactivate(void){	if(!Active)		return;		if (TimerEventSource)		TimerEventSource->cancelTimeout();		Active = false;	//	InfoLog("Monitoring stopped");}UInt32 FakeSMCIntelMonitor::IntelGetFrequency(UInt8 fid) {	UInt32 multiplier = fid & 0x1f;					// = 0x08	bool half = fid & 0x40;							// = 0x01	bool dfsb = fid & 0x80;							// = 0x00	UInt32 fsb = BusClock >> dfsb;	UInt32 halffsb = BusClock >> 1;						// = 200	UInt32 frequency = (multiplier * fsb);			// = 3200	return (frequency + (half * halffsb));	// = 3200 + 200 = 3400}UInt32 FakeSMCIntelMonitor::IntelGetVoltage(UInt8 vid) {	switch (CpuCoreTech) {		case IntelPentium:		case IntelPentiumPro:		case IntelPentiumM:			return 700 + ((vid & 0x3F) << 4);			break;		case IntelNetburstOld:		case IntelNetburstNew:		case IntelCore:			return  CpuMobile ? (1425 + ((vid & 0x3F) * 25)) >> 1 : (1650 + ((vid & 0x3F) * 25)) >> 1;			break;		case IntelCore45:		case IntelCoreI7:		case IntelAtom:			return  (1500 - (((~vid & 0x3F) * 25) >> 1));			break;		case AMDK7:		case AMDK8BC:		case AMDK8D:		case AMDK8E:		case AMDK8NPT:			return 1550 - (vid * 25);			break;		case AMDK10:		case AMDK11:			return (3100 - (vid * 25)) >> 1;			break;		default:			return 0;			break;	}		return 0;}