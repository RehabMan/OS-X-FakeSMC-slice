/* *  FakeSMCIntelMonitor.h *  FakeSMCIntelMonitor * *  Created by mozodojo on 18/05/10. *  Copyright 2010 mozodojo. All rights reserved. * */#ifndef FAKESMC_INTELMONITOR#define FAKESMC_INTELMONITOR#include <IOKit/IOService.h>#include <IOKit/IOTimerEventSource.h>#include <IOKit/IOLib.h>#include <libkern/OSTypes.h>#include <i386/proc_reg.h>#include <IOKit/IODeviceTreeSupport.h>#include "cpuid.h"#include "FakeSMCBinding.h"#define DebugOn FALSE#define LogPrefix "IntelMonitor: "#define DebugLog(string, args...)	do { if (DebugOn) { IOLog (LogPrefix "[Debug] " string "\n", ## args); } } while(0)#define WarningLog(string, args...) do { IOLog (LogPrefix "[Warning] " string "\n", ## args); } while(0)#define InfoLog(string, args...)	do { IOLog (LogPrefix string "\n", ## args); } while(0)#define CTL(fid, vid)	(((fid) << 8) | (vid))#define FID(ctl)		(((ctl) & 0xff00) >> 8)#define VID(ctl)		((ctl) & 0x00ff)#define MSR_P4_EBC_FREQUENCY_ID		0x002C#define MSR_M_PSB_CLOCK_STS			0x00CD#define MSR_PLATFORM_INFO			0x00CE#define MSR_IA32_MPERF				0x00E7#define MSR_IA32_APERF				0x00E8#define MSR_IA32_EXT_CONFIG			0x00EE//#define MSR_IA32_PERF_STS			0x0198 //already defined in proc_reg.h#define MSR_IA32_CLOCK_MODULATION	0x019A#define MSR_IA32_THERM_INTERRUPT	0x019B#define MSR_IA32_THERM_STATUS		0x019C#define MSR_IA32_TEMPERATURE_TARGET	0x01A2#define MSR_AMD_CLKCTL				0xc001001b#define MSR_AMD_FIDVID_CTL			0xc0010041#define MSR_AMD_FIDVID_STS			0xc0010042#define MSR_AMD_PSTATE_LIMIT		0xc0010061#define MSR_AMD_PSTATE_CTL			0xc0010062#define MSR_AMD_PSTATE_STS			0xc0010063#define MSR_AMD_PSTATE_BASE			0xc0010064#define MSR_AMD_COFVID_CTL			0xc0010070#define MSR_AMD_COFVID_STS			0xc0010071extern "C" void mp_rendezvous_no_intrs(void (*action_func)(void *), void * arg);extern "C" int cpu_number(void);enum  {	Unknown,	Intel386,	Intel486,	IntelPentium,	IntelPentiumPro,	IntelPentiumM,	IntelNetburstOld,	IntelNetburstNew,	IntelCore,	IntelAtom,	IntelCore45,	IntelCoreI7,	AMDK5,	AMDK6,	AMDK7,	AMDK8BC,	AMDK8D,	AMDK8E,	AMDK8NPT,	AMDK10,	AMDK11,	CoreTechCount			};const UInt32 Kilo = 1000; //Sliceconst UInt32 Mega = Kilo * 1000;const UInt32 Giga = Mega * 1000;#define defString(s) defXString(s)#define defXString(s) #sconst char * kextVersion = defString(KEXT_VERSION);const char * kextProductName = defString(KEXT_PRODUCTNAME);const char * kextOSX = defString(KEXT_OSX);const char * kextConfig = defString(KEXT_CONFIG);const char * kextBuildDate = __DATE__;const char * kextBuildTime = __TIME__;struct PState {	union 	{		UInt16 Control;		struct 		{			UInt8 VID;	// Voltage ID			UInt8 FID;	// Frequency ID		};	};		UInt8	DID;		// DID	UInt8	CID;		// Compare ID};#define MaxCpuCount		16#define MaxPStateCount	32static UInt8				GlobalThermal[MaxCpuCount];static bool					GlobalThermalValueIsObsolete[MaxCpuCount];static PState				GlobalState[MaxCpuCount];inline void IntelWaitForSts(void) {	UInt32 inline_timeout = 100000;	while (rdmsr64(MSR_IA32_PERF_STS) & (1 << 21)) { if (!inline_timeout--) break; }}void IntelState(__unused void * magic){	UInt32 i = cpu_number();	GlobalState[i].Control = rdmsr64(MSR_IA32_PERF_STS) & 0xFFFF;}void IntelThermal(__unused void * magic){	UInt32 i = cpu_number();	UInt64 msr = rdmsr64(MSR_IA32_THERM_STATUS);	if (msr & 0x80000000) {		GlobalThermal[i] = (msr >> 16) & 0x7F;		GlobalThermalValueIsObsolete[i]=false;	}}class FakeSMCIntelMonitor : public IOService{    OSDeclareDefaultStructors(FakeSMCIntelMonitor)  public:		int						CpuTjmax;	UInt32					Frequency[MaxCpuCount];	UInt32					Voltage[MaxCpuCount];private:	bool					Active;		bool					LoopLock;		UInt32					BusClock;	UInt32					FSBClock;		bool					CpuMobile;	bool					CpuNonIntegerBusRatio;	bool					CpuDynamicFSB;	UInt8					CpuCoreTech;	UInt32					CpuSignature;	UInt32					CpuClock;		UInt8					CpuCount;		Binding*			FreqBinding[MaxCpuCount];	Binding*			VoltBinding[MaxCpuCount];	Binding*			TempBinding[MaxCpuCount];		PState					PStateInitial;	PState					PStateMinimum;	PState					PStateMaximum;		UInt8					PStatesCount;	PState					PStates[MaxPStateCount];	float					Performance[MaxCpuCount];			IOWorkLoop *			WorkLoop;	IOTimerEventSource *	TimerEventSource;	void					Activate(void);	void					Deactivate(void);	UInt32					IntelGetFrequency(UInt8 fid);	UInt32					IntelGetVoltage(UInt8 vid);	public:	virtual IOReturn	loopTimerEvent(void);	virtual IOService*	probe(IOService *provider, SInt32 *score);    virtual bool		start(IOService *provider);	virtual bool		init(OSDictionary *properties=0);	virtual void		free(void);	virtual void		stop(IOService *provider);		};#endif